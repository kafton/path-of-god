#!/usr/bin/env python3
"""
Advanced safe self-rewriting AI (fixed).
- Safe memory file (ai_memory.json)
- Safe rewrite tags (START_TAG/END_TAG properly quoted)
- Rewrites only the code inside the AI_REWRITE block
- Generates improved ai_decision_engine based on memory
"""

import json
import os
import re
from datetime import datetime

AI_FILE = os.path.abspath(__file__)
MEMORY_FILE = "ai_memory.json"

# -------------------------------------------------------------------
# MEMORY SYSTEM
# -------------------------------------------------------------------
def load_memory():
    if not os.path.exists(MEMORY_FILE):
        return {"knowledge": 1, "reward": 0, "history": []}
    with open(MEMORY_FILE, "r", encoding="utf-8") as f:
        return json.load(f)


def save_memory(memory):
    with open(MEMORY_FILE, "w", encoding="utf-8") as f:
        json.dump(memory, f, indent=4)


memory = load_memory()

# -------------------------------------------------------------------
# AI REWARD AND IMPROVEMENT LOGIC
# -------------------------------------------------------------------
def reward_ai(amount=1):
    memory["reward"] = memory.get("reward", 0) + amount
    memory["knowledge"] = memory.get("knowledge", 0) + amount
    memory.setdefault("history", []).append(
        {
            "time": datetime.utcnow().isoformat() + "Z",
            "event": f"AI improved knowledge by {amount}",
        }
    )
    save_memory(memory)


# -------------------------------------------------------------------
# SELF-REFLECTION SYSTEM
# -------------------------------------------------------------------
def reflect(memory_obj):
    k = memory_obj.get("knowledge", 0)
    r = memory_obj.get("reward", 0)

    reflection = (
        f"The AI currently has:\n"
        f"- Knowledge Level: {k}\n"
        f"- Reward Score: {r}\n\n"
        "Reflection:\n"
        "I will focus on improving internal functions inside allowed blocks.\n"
    )

    memory_obj.setdefault("history", []).append(
        {"time": datetime.utcnow().isoformat() + "Z", "reflection": reflection}
    )
    save_memory(memory_obj)
    return reflection


# -------------------------------------------------------------------
# SAFE SELF-REWRITING ENGINE
# -------------------------------------------------------------------

START_TAG = "# === AI_REWRITE_START ===
# Auto-generated AI logic – Level 4
def ai_decision_engine():
    """
    Auto-generated decision engine.
    Knowledge: 4, Reward: 3
    Returns a dict with a deterministic decision_value.
    """
    knowledge = 4
    reward = 3
    decision = (knowledge * 10) + reward
    return {
        "knowledge": knowledge,
        "reward": reward,
        "decision_value": decision,
        "description": "Deterministic decision generated by AI evolver."
    }

# === AI_REWRITE_END ==="

def generate_improved_code(old_code_block, memory_obj):
    """Generate an improved ai_decision_engine based on memory."""
    lvl = int(memory_obj.get("knowledge", 1))
    reward = int(memory_obj.get("reward", 0))

    new_code = f'''# Auto-generated AI logic – Level {lvl}
def ai_decision_engine():
    """
    Auto-generated decision engine.
    Knowledge: {lvl}, Reward: {reward}
    Returns a dict with a deterministic decision_value.
    """
    knowledge = {lvl}
    reward = {reward}
    decision = (knowledge * 10) + reward
    return {{
        "knowledge": knowledge,
        "reward": reward,
        "decision_value": decision,
        "description": "Deterministic decision generated by AI evolver."
    }}
'''
    return new_code


def rewrite_self():
    # Read own file
    with open(AI_FILE, "r", encoding="utf-8") as f:
        content = f.read()

    # Find rewrite block
    pattern = re.compile(
        re.escape(START_TAG) + r"(.*?)" + re.escape(END_TAG),
        re.DOTALL
    )
    m = pattern.search(content)
    if not m:
        print("❌ Rewrite markers not found. No changes made.")
        return False

    old_block = m.group(1)
    new_block = "\n" + generate_improved_code(old_block, memory) + "\n"

    updated = content[:m.start(1)] + new_block + content[m.end(1):]

    # Safety check: tags must remain
    if START_TAG not in updated or END_TAG not in updated:
        print("❌ Safety check failed: tags missing after update.")
        return False

    # Atomic write
    tmp = AI_FILE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        f.write(updated)
    os.replace(tmp, AI_FILE)

    print("✅ AI successfully rewrote its own code.")
    return True


# -------------------------------------------------------------------
# MAIN EXECUTION
# -------------------------------------------------------------------
def main():
    print("=== AI SELF EVOLUTION START ===")
    print(f"Current knowledge: {memory.get('knowledge')} | reward: {memory.get('reward')}")

    reflect(memory)
    reward_ai(1)

    ok = rewrite_self()
    if ok:
        memory.setdefault("history", []).append({
            "time": datetime.utcnow().isoformat() + "Z",
            "event": "rewrite_success"
        })
        save_memory(memory)

    print("AI knowledge increased to:", memory.get("knowledge"))
    print("=== AI SELF EVOLUTION END ===")


if __name__ == "__main__":
    main()


# -------------------------------------------------------------------
# REWRITE BLOCK
# -------------------------------------------------------------------
# The AI will rewrite everything inside this block:

# === AI_REWRITE_START ===
def ai_decision_engine():
    return {"msg": "initial version"}
# === AI_REWRITE_END ===
